"""
Module for image related tools
#TODO Improve images generated by getting the llm to generate the prompt for the image
"""

import base64
import io
import requests
from PIL import Image, PngImagePlugin
from .custom_tools import CustomBaseTool

class CustomGenerateImageTool(CustomBaseTool):
    """
    Class representing a tool used for generating image using stable diffusion API
    Note that Automatic1111 should be run using -api flag
    """
    generation_steps : int = None
    api_url : str = None
    output_filename : str = None
    save_image = True

    def __init__(self, fact,
            vdb = None,
            return_direct = False,
            api_url = None,
            generation_steps = 10,
            output_filename = './generated_images/output.png',
            save_image = True
        ):
        super().__init__(fact,
                name="Preview_Image",
                description="Use this tool to when instructed to preview image or a picture. "
                "The 'Action Input:' for this tool should be prompt optimized for stable diffusion",
                vdb = vdb,
                return_direct = return_direct
            )
        self.generation_steps = generation_steps
        self.api_url = api_url
        self.output_filename = output_filename
        self.save_image = save_image

    def save_image_as_png(self, image_base_64 : str, image_str : str):
        """
        Saving as a PNG. Getting PNG info via API also
        Is there a good reason to (re-)save it to file?
        """
        image = Image.open(io.BytesIO(base64.b64decode(image_base_64)))
        png_payload = {"image": "data:image/png;base64," + image_str}
        response2 = requests.post(url=f'{self.api_url}/sdapi/v1/png-info', json=png_payload)
        pnginfo = PngImagePlugin.PngInfo()
        pnginfo.add_text("parameters", response2.json().get("info"))
        file_name = f'{self.output_filename}' # Add timestamps in filename
        print( f'Generated image and saved at {file_name}')
        image.save(file_name, pnginfo=pnginfo)

    # Would be nice to implement an async version since does take a while
    def _run(self, query: str) -> str:
        payload = { "prompt": query, "steps": self.generation_steps }
        response = requests.post(url=f'{self.api_url}/sdapi/v1/txt2img', json=payload)
        # Check response codes, handle errors
        resp = response.json()
        for i in resp['images']: # Assumes single image
            image_base_64 = i.split(",",1)[0]
            if self.save_image is True:
                self.save_image_as_png(image_base_64, i)
            return f'BASE64ENCODED:{image_base_64}'
        return 'Ooops, No image generated.'

    async def _arun(self, query: str) -> str:
        raise NotImplementedError("does not support async")

class SearchImageTool(CustomBaseTool):
    """
     Class which searches and returns images - Only supported with Bard Experimental
    """
    def __init__(self, fact, return_direct = False):
        super().__init__(fact,
                name="Search_Image",
                description="Use this tool when asked to find or search for an image",
                return_direct = return_direct
            )

    def _run(self, query: str) -> str:
        if self.factory.image_support() is True:
            self.factory.llm.set_next_response_for_images()

        print("Running Search Image Tool")
        image_links = self.factory.llm(query)
        if len(image_links) > 0:
            first_image = Image.open(requests.get(image_links[0], stream=True).raw).convert("RGB")
            return  f'BASE64ENCODED:{base64.b64encode(first_image)}'

        return "No Images"

    async def _arun(self, query: str) -> str:
        raise NotImplementedError("does not support async")
